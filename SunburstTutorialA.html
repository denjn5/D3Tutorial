<!DOCTYPE html>
<head>
    <script src="Libraries/d3.v4.js"></script>
</head>
<body>
    <svg></svg>
</body>

<script>
    // json value has 1 primary name ("topics")
    var nodeData = {
        "name": "TOPICS", "children": [{
            "name": "Topic 1",
            "children": [{"name": "Sub 1a", "size": 4}, {"name": "Sub 1b", "size": 4}, {
                "name": "Sub 1c", "size": 4}]
        }, {
            "name": "Topic 2",
            "children": [{"name": "Sub 2a", "size": 3}, {"name": "Sub 2b", "size": 3}, {
                "name": "Sub 2c", "size": 3}]
        }, {
            "name": "Topic 3",
            "children": [{"name": "Sub 3a", "size": 3}, {"name": "Sub 3b", "size": 3}, {
                "name": "Sub 3c", "size": 2}]
        }]
    };

    /* We're mostly just setting 4 variables here. But there's a few things here that are worth commenting on:

    var width = 500 creates a variable set to 500, it does not actually set the width of anything, yet. That will
    happen below when we apply our new variable to an actual HTML element's width attribute. Why not just set width
    and height directly? Because we'll use these same variables to also size our sunburst (radius) and to re-orient
    the 0,0 center of the <SVG> element to the middle of the element (instead of its natural upper-left starting
    point).

    var radius = Math.min(width, height) / 2 determines which is smaller, width or height, then it divides that
    smaller value by 2 and sets the answer to radius. This works well, since we don't want our sunburst to overflow
    our <svg> element. Since both width and height are 500 here, the radius variable will equal 250. Eventually,
    this will become our sunburst's radius, once we do something with the variable.

    d3.scaleOrdinal: Scales help us map something in our data to something visual. Outside of d3, *ordinal scales*
    indicate direction and provide some nominal information (e.g., low, medium, high). schemeCategory20b is a color
    scheme in d3 that's specifically designed to fill a d3.scaleOrdinal. The result of this line is that we'll have
    a variable (color) that's filled with a series of colors that can be doled out to represent a something in our
    sunburst. */
    var width = 500;
    var height = 500;
    var radius = Math.min(width, height) / 2;
    var color = d3.scaleOrdinal(d3.schemeCategory20b);

    /* d3.select('svg') selects our <svg></svg> element so that we can work with it. The select command finds the
    first element (and only the first, if there are multiple) that matches the specified selector string
    ("svg" in this case). If select doesn't find a match, it returns an empty selection. Alternatively, we could have
    skipped created the <svg> tags using d3 by selecting the body element and appending an svg element to it:
    d3.select("body").append("svg")

    .attr('width', width) sets the width attribute of our previously selected <svg> element. In HTML,
    we could have said <svg width="500">. If the width variable was not included .attr('width') would return the value
    of the width element.

    .append('g') adds a <g> element to our SVG. <g> is a special SVG element that acts as a container; it's used
    to group other SVG elements. Transformations applied to the <g> element are performed on all of its child elements,
    and any of its attributes are inherited by its child elements.

    .attr('transform', [translate function]) looks a bit more complex.  As above, attr sets the value for the
    'transform' attribute. The transform attribute allows us to scale, translate (move), rotate, etc. our <g> element
    and it's children. In this case we'll move our <g> element using the translate function.

    'translate(' + width / 2 + ',' + height / 2 + ')'. If our width and height are each 400, this formula resolves to
    translate(200, 200). And it will move the coordinate system for our <g> element 200 units right (x-axis) and 200
    units down (y-axis). This can be a bit confusing, and brings up 2 questions: First, why "down"?
    Because <svg>'s coordinate system starts with 0,0 in the upper-left corner; x values move things to the
    right and y values move things down. Second, what's the point this translate statement? It moves 0,0 from the
    upper-left corner to the *center* of our <svg> element. Now, our <svg> container, if it's 400 wide, stretches
    from -200 to 200, instead of 0 to 400. If you wanna dive deeper, Sara Soueidan's article helps clarify the
    mechanics. It's worth a read: https://sarasoueidan.com/blog/svg-transformations/.  */

    var g = d3.select('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

    /* (NOTE: d3 leverages method chaining. That means that we can sometimes connect multiple commands together into a
    single statement, like we've done below. To understand method chaining, it's important to recognize that each
    method returns something, and the next method in the chain applies to that something. To keep it simple for now,
    let's just look at how it works in the example below:
    1) d3.select('svg') returns a handle to the <svg> element.
    2) attr('width', width) sets the width of <svg> and then returns the <svg> element.
    3) attr('height', height) sets the height of <svg> and then returns the <svg> element.
    4) append('g') adds a <g> element to the <svg> element, then it returns the <g> element.
    5) attr('transform', ...) transforms the <g> element.
    This chaining happens all over the place and is key to understanding d3 (and jQuery). So understanding a full
    statement requires understanding the methods and what they return!) */


    /* The partition command is a special tool that helps size the slices of our sunburst correctly.  It ensures that
    we use all 360 degrees of the circle, and that each slice is sized relative to the other slices.  If an underlying
    datum has a size that is 2 times as large as another datum, then partition helps us see that in the final
    product. (Though the hierarchy command below plays an important role also.)

    size sets this partition's overall size ["width", "height"].
    * 2π is the number of radians to set your circle a full 360°. Want a ½ circle? Set size as π (Math.PI).
    * radius sets the overall distance from the center to the outside of the circle; we set this distance way above
    based on the size of our <svg> element. */
    var partition = d3.partition()
        .size([2 * Math.PI, radius]);
    /*
    LATER: 1/2 circle, 1/4 circle, 75% of the radius
    */


    /* For the sunburst layout (or any hierarchical layout, for that matter), d3 needs a "root node". Happily, our data
    is already in a hierarchical pattern and has a root node (root node name = "TOPICS").  So we can pass our data
    directly to d3.partition with no preliminary massaging..

    sum() determines how "long" each of our slices is (by "long", I mean how far the slice stretches around the
    circle). So it needs to see our data to be able to calculate the total "size" of all slices in a ring.  d3's
    pattern for getting access to your data always looks like this: function(d) { return d }.  Only the "return d"
    part can get pretty intricate.  We've asked d3 to size each slice based on the "size" element within each datum.

    is theoretically simple: it adds up whatever is in the function and returns it.



     */
    var root = d3.hierarchy(nodeData)
        .sum(function (d) { return d.size});
    /* LATER: if (d.children) { return 0} else { return 1 }, size = 1, size by slice count vs size by size.
    * Add sort (or is that above?)*/


    partition(root);

    var arc = d3.arc()
        .startAngle(function (d) { return d.x0 })
        .endAngle(function (d) { return d.x1 })
        .innerRadius(function (d) { return d.y0 })
        .outerRadius(function (d) { return d.y1 });

    var path = g.selectAll('path')
        .data(root.descendants())
        .enter().append('path')
        .attr("display", function (d) { return d.depth ? null : "none"; })
        .attr("d", arc)
        .attr("fill-rule", "evenodd")
        .style('stroke', '#fff')
        .style("fill", function (d) { return color((d.children ? d : d.parent).data.name); });
</script>
