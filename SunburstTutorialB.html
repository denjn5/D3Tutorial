<!DOCTYPE html>
<head>
    <script src="Libraries/d3.v4.js"></script>
</head>
<body>
    <svg></svg>
</body>

<script>

    // Variables
    var width = 500;
    var height = 500;
    var radius = Math.min(width, height) / 2;
    var color = d3.scaleOrdinal(d3.schemeCategory20b);
    var x = d3.scaleLinear().range([0, 2 * Math.PI]);
    var y = d3.scaleSqrt().range([0, radius]);

    // Size our <svg> element, add a <g> element, and move translate 0,0 to the center of the element.
    var g = d3.select('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

    // Create our sunburst data structure and size it.
    var partition = d3.partition()
        .size([2 * Math.PI, radius]);

    /* Get the data from our JSON file
    d3 includes a super-simple function that allows us to pull our data from a json file (other functions exist for
    csv, tsv, etc.).

    d3.json("data.json", function(error, nodeData) includes the filename (assumes that this file is in the same
    directory as the original html file) and a special "anonymous" function that returns either an error and a variable
    name ("nodeData").
     */
    d3.json("data.json", function(error, nodeData) {
        if (error) throw error;

        // Find the root node of our data, and begin sizing process.
        // nodeData is now from our external json file, rather than a locally defined variable.
        var root = d3.hierarchy(nodeData)
            .sum(function (d) { return d.size});

        // Calculate the sizes of each arc that we'll draw later.
        partition(root);
        var arc = d3.arc()
            .startAngle(function (d) { return d.x0 })
            .endAngle(function (d) { return d.x1 })
            .innerRadius(function (d) { return d.y0 })
            .outerRadius(function (d) { return d.y1 });


        // Draw the <path> elements within <g> based on our data and the arc variable calculations.
        // Then color the lines and the slices.
        /* In the previous tutorial, we selected our non-existent <path> elements below and used the d3 Update Pattern to
        add a <path> for each node in our data. This time, we want to add visible <text> elements. Sadly, <path> cannot
        contain <text> elements. Instead, we'll add the <g> element, which is all about corralling other elements.

        We've made the 2 changes to our previous code, intended to fit our <path> element inside of a <g> element:
        1) "g.selectAll('path')" --> "g.selectAll('g')"
        2) ".enter().append('path')" --> ".enter().append('g').attr("class", "node").append('path')"

        In step 2, we now append a <g> element for each data node. To that, we add an html class attribute ("node")
        so that we can get a hold of just the <g class='node'> elements later. And now we append the <path> element to
        the new <g class='node'> elements. In the end, each data node has an entry that looks like:

        <g class="node">
            <path d="..." style="..."></path>
        </g>

        The rest of this block remains the same as the previous tutorial. */
        g.selectAll('g')
            .data(root.descendants())
            .enter().append('g').attr("class", "node").append('path')
            .attr("display", function (d) { return d.depth ? null : "none"; })
            .attr("d", arc)
            .style('stroke', '#fff')
            .style("fill", function (d) { return color((d.children ? d : d.parent).data.name); });


        /* Now we'll add and populate the <text> elements with our data-driven titles.

        1) g.selectAll(".node") like the last block, starts with the g variable that we created way above; it references
        the <g> element that we originally appended to our <svg> element. But it does as selectAll on the newly created
        <g class='node'> elements from the block above.

        2) .append("text") appends an empty <text> element to each <g class='node'> element

        3) .attr("transform", function(d) {
            return "translate(" + arc.centroid(d) + ")rotate(" + computeTextRotation(d) + ")"; }) adds a transform
                attribute to each our newly created <text> elements.
            * "translate(" + arc.centroid(d) + ")" moves the reference point for this <text> element to the center of each
            arc (the variable we defined above). The centroid command from d3 computes the midpoint [x, y] of each arc.
            * "rotate(" + computeTextRotation(d) + ")" then we'll rotate our <text> element a specified number of
            degrees. We'll do that calc in a separate function below.

        4) .attr("dx", "-20")  // Moves the text element to the left, which makes our labels look centered.
        5) .attr("dy", ".5em") // Pulls our text element in closer to the center of the Sunburst, which makes our
            labels look centered.
        6) .text(function(d) { return d.parent ? d.data.name : "" }) returns the "name" attribute for each node, unless
            that particular node has no parents (the "root" node).  In that case, it returns an empty string.

        Putting this block all together, each data node has an entry that looks like:
        <g class="node">
            <path d="..." style="..."></path>
            <text transform="translate(105.5409906877519,-66.97834937237457)rotate(-32.39999999999999)"
                dx="-20" dy=".35em">Topic A</text>
        </g>

         */
        g.selectAll(".node")
            .append("text")
            .attr("transform", function(d) {
                return "translate(" + arc.centroid(d) + ")rotate(" + computeTextRotation(d) + ")"; })
            .attr("dx", "-20") // radius margin
            .attr("dy", ".5em") // rotation align
            .text(function(d) { return d.parent ? d.data.name : "" });

    });


/* computeTextRotation spins our label clockwise based on the location of the slice in the sunburst. It avoids
* upside down labels.
* @param {d3 Node} d
* @return {Number}
 */
    function computeTextRotation(d) {
        /* Calculate the angle (in degrees) of the label that will work for 1/2 of the labels.
        d.x0 = the beginning angle of this node / slice (in radians).
        d.x1 = the end angle of this node / slice (in radians).
         */
        var angle = (d.x0 + d.x1) / Math.PI * 90;

        // Handle rotation to avoid any upside-down labels: If rotation angle is in the 1st or 2nd quadrants (top 1/2),
        // leave the already calc'd angle. Otherwise, flip the text over so that the text appears right-side-up.
        return (angle < 90 || angle > 270) ? angle : angle + 180;  // "labels aligned with slices"

        // Alternatively, the line below performs rotates the labels so that they appear in the traditional "spoke"
        // formation. It avoids any upside-down labels.
        //return (angle < 180) ? angle - 90 : angle + 90;  // "labels as spokes"
    }

</script>




















