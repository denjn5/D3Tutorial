<!DOCTYPE html>
<head>
    <script src="Libraries/d3.v4.js"></script>
</head>
<body>
    <svg></svg>
</body>

<script>

    /* Next steps
    1) Pull data from json
    2) Add labels

    */

    var nodeData = {
        "name": "TOPICS", "children": [{
            "name": "Topic A",
            "children": [{"name": "Sub A1", "size": 4}, {"name": "Sub A2", "size": 4}]
        }, {
            "name": "Topic B",
            "children": [{"name": "Sub B1", "size": 3}, {"name": "Sub B2", "size": 3}, {
                "name": "Sub B3", "size": 3}]
        }, {
            "name": "Topic C",
            "children": [{"name": "Sub A1", "size": 4}, {"name": "Sub A2", "size": 4}]
        }]
    };


    var width = 500;
    var height = 500;
    var radius = Math.min(width, height) / 2;
    var color = d3.scaleOrdinal(d3.schemeCategory20b);
    var x = d3.scaleLinear().range([0, 2 * Math.PI]);
    var y = d3.scaleSqrt().range([0, radius]);

    // Size our <svg> element, add a <g> element, and move translate 0,0 to the center of the element.
    var g = d3.select('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

    // Create our sunburst data structure and size it.
    var partition = d3.partition()
        .size([2 * Math.PI, radius]);


    // Find the root node of our data, and begin sizing process.
    var root = d3.hierarchy(nodeData)
        .sum(function (d) { return d.size});

    // Calculate the sizes of each arc that we'll draw later.
    partition(root);
    var arc = d3.arc()
        .startAngle(function (d) { return d.x0 })
        .endAngle(function (d) { return d.x1 })
        .innerRadius(function (d) { return d.y0 })
        .outerRadius(function (d) { return d.y1 });

    // Draw the <path> elements within <g> based on our data and the arc variable calculations.
    // Then color the lines and the slices.
    /* In the previous tutorial, we selected our non-existent <path> elements below and used the d3 Update Pattern to
    add a <path> for each node in our data. This time, we want to add visible <text> elements. Sadly, <path> cannot
    contain <text> elements. Instead, we'll add the <g> element, which is all about corralling other elements.

    We've made the 2 changes to our previous code, intended to fit our <path> element inside of a <g> element:
    1) "g.selectAll('path')" --> "g.selectAll('g')"
    2) ".enter().append('path')" --> ".enter().append('g').attr("class", "node").append('path')"

    In step 2, we now append a <g> element for each data node. To that, we add an html class attribute ("node")
    so that we can get a hold of just the <g class='node'> elements later. And now we append the <path> element to
    the new <g class='node'> elements. In the end, each data node has an entry that looks like:

    <g class="node">
        <path d="..." style="..."></path>
    </g>

    The rest of this block remains the same as the previous tutorial. */
    g.selectAll('g')
        .data(root.descendants())
        .enter().append('g').attr("class", "node").append('path')
        .attr("display", function (d) { return d.depth ? null : "none"; })
        .attr("d", arc)
        .style('stroke', '#fff')
        .style("fill", function (d) { return color((d.children ? d : d.parent).data.name); });

    /* Now we'll add and populate the <text> elements with our data-driven titles.

    1) g.selectAll(".node") like the last block, starts with the g variable that we created way above; it references
    the <g> element that we originally appended to our <svg> element. But it does as selectAll on the newly created
    <g class='node'> elements from the block above.

    2) .append("text") appends an empty <text> element to each <g class='node'> element

    3) .attr("transform", function(d) {
        return "translate(" + arc.centroid(d) + ")rotate(" + computeTextRotation(d) + ")"; }) adds a transform
    attribute to each our newly created <text> elements.
        * "translate(" + arc.centroid(d) + ")" moves the reference point for this <text> element to the center of each
        arc (the variable we defined above). The centroid command from d3 computes the midpoint [x, y] of each arc.
        * "rotate(" + computeTextRotation(d) + ")" then, well, rotates, our <text> element a specified number of
        degrees.

    4) .attr("dx", "-20") // radius margin
    5) .attr("dy", ".35em") // rotation align
    6) .text(function(d) { return d.parent ? d.data.name : "" })

    Putting this block all together, each data node has an entry that looks like:
    <g class="node">
        <path d="..." style="..."></path>
        <text transform="translate(105.5409906877519,-66.97834937237457)rotate(-32.39999999999999)"
            dx="-20" dy=".35em">Topic A</text>
    </g>

     */
    g.selectAll(".node")
        .append("text")
        .attr("transform", function(d) {
            return "translate(" + arc.centroid(d) + ")rotate(" + computeTextRotation(d) + ")"; })
        .attr("dx", "-20") // radius margin
        .attr("dy", ".35em") // rotation align
        .text(function(d) { return d.parent ? d.data.name : "" })
    ;


    function computeTextRotation(d) {
        var angle = (d.x0 + d.x1) / Math.PI * 90;
        //return (angle >= 45 && angle <= 180) ? angle : angle;
        return (angle > 90 && angle < 270) ? angle + 180 : angle;
    }

</script>




















